amcl:
  ros__parameters:
    use_sim_time: False
    alpha1: 0.2
    alpha2: 0.2
    alpha3: 0.2
    alpha4: 0.2
    alpha5: 0.2
    base_frame_id: "aft_mapped"
    beam_skip_distance: 0.5
    beam_skip_error_threshold: 0.9
    beam_skip_threshold: 0.3
    do_beamskip: false
    global_frame_id: "map"
    lambda_short: 0.1
    laser_likelihood_max_dist: 2.0
    laser_max_range: 100.0
    laser_min_range: -1.0
    laser_model_type: "likelihood_field"
    max_beams: 60
    max_particles: 3000
    min_particles: 1000
    odom_frame_id: "odom"
    pf_err: 0.05
    pf_z: 0.99
    recovery_alpha_fast: 0.0
    recovery_alpha_slow: 0.0
    resample_interval: 1
    robot_model_type: "nav2_amcl::OmniMotionModel"
    save_pose_rate: 0.5
    sigma_hit: 0.2
    tf_broadcast: true
    transform_tolerance: 1.0
    update_min_a: 0.2
    update_min_d: 0.25
    z_hit: 0.5
    z_max: 0.05
    z_rand: 0.5
    z_short: 0.05
    scan_topic: /scan
    map_topic: /map
    set_initial_pose: True
    # # 核心修正：添加初始偏航角偏移（单位：弧度）
    # # 根据之前测量的map与odom的yaw偏差值设置（例如偏差62.45度，对应-1.09弧度）
    # initial_pose_yaw: -1.09
    # # 可选：放宽初始角度的协方差，让AMCL更快收敛到正确方向
    initial_pose_covariance:
      x: 0.1
      y: 0.1
      yaw: 0.1

bt_navigator:
  ros__parameters:
    use_sim_time: False
    global_frame: map
    robot_base_frame: base_link_fake
    #robot_base_frame: base_link
    odom_topic: /odometry_path
    bt_loop_duration: 10
    default_server_timeout: 20
    # 'default_nav_through_poses_bt_xml' and 'default_nav_to_pose_bt_xml' are use defaults:
    # nav2_bt_navigator/navigate_to_pose_w_replanning_and_recovery.xml
    # nav2_bt_navigator/navigate_through_poses_w_replanning_and_recovery.xml
    # They can be set here or via a RewrittenYaml remap from a parent launch file to Nav2.
    plugin_lib_names:
      - nav2_compute_path_to_pose_action_bt_node
      - nav2_compute_path_through_poses_action_bt_node
      - nav2_smooth_path_action_bt_node
      - nav2_follow_path_action_bt_node
      - nav2_spin_action_bt_node
      - nav2_wait_action_bt_node
      - nav2_assisted_teleop_action_bt_node
      - nav2_back_up_action_bt_node
      - nav2_drive_on_heading_bt_node
      - nav2_clear_costmap_service_bt_node
      - nav2_is_stuck_condition_bt_node
      - nav2_goal_reached_condition_bt_node
      - nav2_goal_updated_condition_bt_node
      - nav2_globally_updated_goal_condition_bt_node
      - nav2_is_path_valid_condition_bt_node
      - nav2_initial_pose_received_condition_bt_node
      - nav2_reinitialize_global_localization_service_bt_node
      - nav2_rate_controller_bt_node
      - nav2_distance_controller_bt_node
      - nav2_speed_controller_bt_node
      - nav2_truncate_path_action_bt_node
      - nav2_truncate_path_local_action_bt_node
      - nav2_goal_updater_node_bt_node
      - nav2_recovery_node_bt_node
      - nav2_pipeline_sequence_bt_node
      - nav2_round_robin_node_bt_node
      - nav2_transform_available_condition_bt_node
      - nav2_time_expired_condition_bt_node
      - nav2_path_expiring_timer_condition
      - nav2_distance_traveled_condition_bt_node
      - nav2_single_trigger_bt_node
      - nav2_goal_updated_controller_bt_node
      - nav2_is_battery_low_condition_bt_node
      - nav2_navigate_through_poses_action_bt_node
      - nav2_navigate_to_pose_action_bt_node
      - nav2_remove_passed_goals_action_bt_node
      - nav2_planner_selector_bt_node
      - nav2_controller_selector_bt_node
      - nav2_goal_checker_selector_bt_node
      - nav2_controller_cancel_bt_node
      - nav2_path_longer_on_approach_bt_node
      - nav2_wait_cancel_bt_node
      - nav2_spin_cancel_bt_node
      - nav2_back_up_cancel_bt_node
      - nav2_escape_action_bt_node
      - nav2_assisted_teleop_cancel_bt_node
      - nav2_drive_on_heading_cancel_bt_node
      - nav2_is_battery_charging_condition_bt_node

bt_navigator_navigate_through_poses_rclcpp_node:
  ros__parameters:
    use_sim_time: False

bt_navigator_navigate_to_pose_rclcpp_node:
  ros__parameters:
    use_sim_time: False

recoveries_server:
  ros__parameters:
    costmap_topic: local_costmap/costmap_raw
    footprint_topic: local_costmap/published_footprint
    cycle_frequency: 10.0
    recovery_plugins: ["escape","backup"]
    # spin:
    #   plugin: "nav2_recoveries/Spin"
    backup:
      plugin: "nav2_recoveries/BackUp"
    escape:
      plugin: "nav2_recoveries/Escape"
    # wait:
    #   plugin: "nav2_recoveries/Wait"
    global_frame: odom
    robot_base_frame: base_link_fake
    transform_timeout: 0.1
    simulate_ahead_time: 5.0
    max_rotational_vel: 1.0
    min_rotational_vel: 0.4
    rotational_acc_lim: 3.2

controller_server:
  ros__parameters:
    use_sim_time: False
    controller_frequency: 20.0
    min_x_velocity_threshold: 0.001
    min_y_velocity_threshold: 0.5
    min_theta_velocity_threshold: 0.5
    failure_tolerance: 1.0
    progress_checker_plugin: "progress_checker"
    goal_checker_plugins: ["general_goal_checker"] # "precise_goal_checker"
    controller_plugins: ["FollowPath"]

    # Progress checker parameters
    progress_checker:
      plugin: "nav2_controller::SimpleProgressChecker"
      required_movement_radius: 0.5
      movement_time_allowance: 60.0
    # Goal checker parameters
    # precise_goal_checker:
    #  plugin: "nav2_controller::SimpleGoalChecker"
    #  xy_goal_tolerance: 0.25
    #  yaw_goal_tolerance: 0.25
    #  stateful: True
    general_goal_checker:
      stateful: True
      plugin: "nav2_controller::SimpleGoalChecker"
      xy_goal_tolerance: 0.3
      yaw_goal_tolerance: 3.14
    

    # FollowPath:
    #     plugin: "pb_omni_pid_pursuit_controller::OmniPidPursuitController"
    #     translation_kp: 4.0
    #     translation_ki: 0.0
    #     translation_kd: 0.0
    #     enable_rotation: false
    #     rotation_kp: 3.0
    #     rotation_ki: 0.1
    #     rotation_kd: 0.3
    #     transform_tolerance: 0.2
    #     min_max_sum_error: 1.0
    #     lookahead_dist: 1.0
    #     use_velocity_scaled_lookahead_dist: true
    #     lookahead_time: 0.5
    #     min_lookahead_dist: 0.5
    #     max_lookahead_dist: 1.0
    #     use_interpolation: True
    #     use_rotate_to_heading: false
    #     use_rotate_to_heading_treshold: 0.1
    #     min_approach_linear_velocity: 0.0
    #     approach_velocity_scaling_dist: 1.5
    #     v_linear_min: -14.5
    #     v_linear_max: 14.5
    #     v_angular_min: -100.0
    #     v_angular_max: 100.0
    #     curvature_min: 0.4
    #     curvature_max: 0.7
    #     reduction_ratio_at_high_curvature: 0.6
    #     curvature_forward_dist: 1.0
    #     curvature_backward_dist: 0.3
    #     max_velocity_scaling_factor_rate: 0.9


    FollowPath:    
      plugin: "nav2_mppi_controller::MPPIController"
      #param 
      adjustThre: 14.0 # slopeDegree larger than this value will trigger the adjust heading behavior
      minAngleDiff: 365.0 # if the angle difference is larger than this value, the robot will continue to adjust heading
      adjustHeadingSpeed: 0.2 # angular speed to adjust heading
      # 
      time_steps: 56 # prediction horizon = time_steps x model_dt = 3s
      model_dt: 0.05 # =1/controller_frequency
      batch_size: 2000 # Count of randomly sampled candidate trajectories from current optimal control sequence in a given iteration. 1000 @ 50 Hz or 2000 @ 30 Hz seems to produce good results.
      vx_std: 0.5
      vy_std: 0.5
      wz_std: 0.1
      vx_max: 1.0 #1.4 # prediction horizon x vx_max = 3.0 m -->local costmap dim should larger than 3.0 x 2 = 6m
      vx_min: -1.0 # Maximum reverse velocity (m/s).
      vy_max: 1.0
      wz_max: 0.1
      ax_max: 10.0
      ay_max: 10.0
      ax_min: -10.0
      az_max: 0.1

      iteration_count: 1 # Recommended to remain as 1 and instead prefer larger batch sizes.
      prune_distance: 7.2 # proportion to your maximum velocity and prediction horizon. #影响上坡,值越大越上不了
      transform_tolerance: 0.1 # Time tolerance for data transformations with TF (s).
      temperature: 0.3 # 0 mean use control with best cost, huge value will lead to just taking mean of all trajectories without cost consideration.
      gamma: 0.015 #0.07官方默认0.1 # A trade-off between smoothness (high) and low energy (low). This is a complex parameter that likely won’t need to be changed from the default.
      motion_model: "Omni"
      visualize: true # set to true to visualize the trajectories, but it will slow down the computation by a lot
      reset_period: 1.0 # Required time of inactivity to reset optimizer (only in Humble
      regenerate_noises: false
      retry_attempt_limit: 3 # Number of attempts to find feasible trajectory on failure for soft-resets before reporting total failure.
      TrajectoryVisualizer:
        trajectory_step: 5
        time_step: 3
      # AckermannConstraints:
      #   min_turning_r: 0.2
      critics: ["ObstaclesCritic", "GoalCritic", "PathAlignCritic", "PathFollowCritic", "TwirlingCritic"]
      GoalCritic:
        enabled: true
        cost_power: 1
        cost_weight: 5.0
        threshold_to_consider: 2.8 # Minimal distance (m) between robot and goal above which goal distance cost considered. It is wise to start with this as being the same as your prediction horizon to have a clean hand-off with the path follower critic.
        # i.e. When this critic is add to the cost function 越小越上不去坡
      PreferForwardCritic: # moving in the forward direction, rather than reversing.
        enabled: false
        cost_power: 1
        cost_weight: 5
        threshold_to_consider: 0.7 # Distance (m) between robot and goal to stop considering preferring forward and allow goal critics to take over.
      ObstaclesCritic: # 如果容易撞到低矮的障碍物，检查地形分析是否正确然后再调整这个参数
        enabled: true
        cost_power: 1
        repulsion_weight: 0.3 #! Higher radii should correspond to reduced repulsion_weight due to the penalty formation (e.g. inflation_radius - min_dist_to_obstacle). 
        # This is separated from the critical term to allow for fine tuning of obstacle behaviors with path alignment for dynamic scenes without impacting actions which may directly lead to near-collisions. This is applied within the inflation_radius distance from obstacles.
        critical_weight: 20.0
        consider_footprint: false # turn on this can increase computation cost
        collision_cost: 100.0
        collision_margin_distance: 0.05 # 0.05 # Margin distance (m) from collision to apply severe penalty, similar to footprint inflation. Between 0.05-0.2 is reasonable. Note that it will highly influence the controller not to enter spaces more confined than this, so ensure this parameter is set lower than the narrowest you expect the robot to need to traverse through.
        near_goal_distance: 0.2 #0.1 # if the robot is within this distance of the goal, it will not be repelled by obstacles.
        inflation_radius: 0.55 #0.4 # Radius to inflate costmap around lethal obstacles. This should be the same as for your inflation layer (Humble only)
        cost_scaling_factor: 5.0 # Exponential decay factor across inflation radius. This should be the same as for your inflation layer (Humble only)
        inflation_layer_name: ["local_inflation_layer","global_inflation_layer"] 
      PathAlignCritic:
        enabled: true
        cost_power: 1
        cost_weight: 6.0
        max_path_occupancy_ratio: 0.001
        trajectory_point_step: 3 #?
        threshold_to_consider: 2.0 # 0.7 # Distance (m) between robot and goal to stop considering path alignment and allow goal critics to take over. So just keep it same as threshold_to_consider in GoalCritic.
        offset_from_furthest: 20 #2 #  A selection of this value to be ~30% of the maximum velocity distance projected is good 
        # (e.g. if a planner produces points every 2.5cm, 60 can fit on the 1.5m local costmap radius. If the max speed is 0.5m/s with a 3s prediction time, 
        # then 20 points represents 33% of the maximum speed projected over the prediction horizon onto the path). When in doubt, 
        # prediction_horizon_s * max_speed / path_resolution / 3.0 is a good baseline. = 3 * 0.8 / 0.1 /3.0
        use_path_orientations: false
      PathFollowCritic: #? incentivizes making progress along the path, what is the diff between this and PathAlignCritic?
        enabled: true
        cost_power: 1
        cost_weight: 5.0 #越大越不稳定
        offset_from_furthest: 10 # Number of path points after furthest one any trajectory achieves to drive path tracking relative to.
        threshold_to_consider: 0.0 # That is to say, path following will be considered until the robot is within this distance of the goal, at which point the goal critic will take over.
      PathAngleCritic: # This critic penalizes trajectories at a high relative angle to the path. This helps the robot make sharp turns when necessary due to large accumulated angular errors.
        enabled: false
        cost_power: 1 
        cost_weight: 5.0
        offset_from_furthest: 25
        threshold_to_consider: 2.8
        max_angle_to_furthest: 1.0
        mode: 2
      TwirlingCritic:
        enabled: True
        twirling_cost_power: 1
        twirling_cost_weight: 10.0


local_costmap:
  local_costmap:
    ros__parameters:
      update_frequency: 10.0
      publish_frequency: 5.0
      global_frame: odom
      robot_base_frame: base_link_fake
      #robot_base_frame: base_link
      use_sim_time: False
      rolling_window: true
      width: 9
      height: 9
      resolution: 0.05
      robot_radius: 0.15 #0.15
      plugins: ["static_layer","obstacle_layer", "inflation_layer"]
      inflation_layer:
        plugin: "nav2_costmap_2d::InflationLayer"
        cost_scaling_factor: 5.0
        inflation_radius: 0.55 #0.5
      obstacle_layer:
        plugin: "nav2_costmap_2d::ObstacleLayer"
        enabled: true
        observation_sources: livox 
        max_obstacle_height: 1.0
        min_obstacle_height: -1.0
        # rplidar:
        #   topic: /rplidar/scan
        #   max_obstacle_height: 1.0
        #   min_obstacle_height: -1.0
        #   clearing: True
        #   marking: True
        #   data_type: "LaserScan"
        #   raytrace_max_range: 3.0
        #   raytrace_min_range: 0.0
        #   obstacle_max_range: 2.5
        #   obstacle_min_range: 0.0
        livox:
          topic: /scan
          max_obstacle_height: 1.0
          min_obstacle_height: -1.0
          clearing: True
          marking: True
          data_type: "LaserScan"
          raytrace_max_range: 10.0
          raytrace_min_range: 0.1
          obstacle_max_range: 10.0
          obstacle_min_range: 0.1
      # voxel_layer:
      #   plugin: "nav2_costmap_2d::VoxelLayer"
      #   enabled: True
      #   publish_voxel_map: True
      #   origin_z: -0.55
      #   z_resolution: 0.05
      #   z_voxels: 16
      #   min_obstacle_height: 1.0
      #   max_obstacle_height: 1.0
      #   mark_threshold: 0
      #   observation_sources: pointcloud
      #   pointcloud:
      #     topic: /segmentation/obstacle
      #     min_obstacle_height: -1.0
      #     max_obstacle_height: 1.0
      #     clearing: True
      #     marking: True
      #     data_type: "PointCloud2"
      #     raytrace_max_range: 5.0
      #     raytrace_min_range: 0.0
      #     obstacle_max_range: 3.0
      #     obstacle_min_range: 0.0

      static_layer:
        plugin: "nav2_costmap_2d::StaticLayer"
        map_subscribe_transient_local: True
      always_send_full_costmap: True

global_costmap:
  global_costmap:
    ros__parameters:
      update_frequency: 10.0
      publish_frequency: 5.0
      global_frame: map
      robot_base_frame: base_link_fake
      #robot_base_frame: base_link
      use_sim_time: False
      robot_radius: 0.15
      resolution: 0.05
      track_unknown_space: True
      static_map: True
      #plugins: ["static_layer", "obstacle_layer","inflation_layer"]
      plugins: ["static_layer", "inflation_layer"]
      obstacle_layer:
        plugin: "nav2_costmap_2d::ObstacleLayer"
        enabled: False
        observation_sources: livox 
        max_obstacle_height: 100.0
        min_obstacle_height: -100.0
        livox:
          topic: /scan
          max_obstacle_height: 100.0
          min_obstacle_height: -100.0
          clearing: True
          marking: True
          data_type: "LaserScan"
          raytrace_max_range: 10.0
          raytrace_min_range: 0.1
          obstacle_max_range: 10.0
          obstacle_min_range: 0.1
      static_layer:
        plugin: "nav2_costmap_2d::StaticLayer"
        map_subscribe_transient_local: True
        track_unknown_space: True
        map_topic: /map
      inflation_layer:
        plugin: "nav2_costmap_2d::InflationLayer"
        cost_scaling_factor: 5.0 #10.0 #20.0
        inflation_radius: 0.5 #12.0 #0.55     
        always_send_full_costmap: True



map_server:
  ros__parameters :
    use_sim_time: False
    # Overridden in launch by the "map" launch configuration or provided default value.
    # To use in yaml, remove the default "map" value in the tb3_simulation_launch.py file & provide full path to map below.
    yaml_filename: ""

map_saver:
  ros__parameters:
    use_sim_time: False
    save_map_timeout: 5.0
    free_thresh_default: 0.25
    occupied_thresh_default: 0.65
    map_subscribe_transient_local: True

planner_server:
  ros__parameters:
    expected_planner_frequency: 20.0
    use_sim_time: False
    planner_plugins: ["GridBased"]
    GridBased:
      plugin: "nav2_navfn_planner/NavfnPlanner"
      tolerance: 0.2
      use_astar: false
      allow_unknown: true
      use_final_approach_orientation: true
    # GridBased:
    #   plugin: "nav2_theta_star_planner/ThetaStarPlanner" # In Iron and older versions, "/" was used instead of "::"
    #   how_many_corners: 8
    #   w_euc_cost: 1.0
    #   w_traversal_cost: 2.0
    #   w_heuristic_cost: 1.0

smoother_server:
  ros__parameters:
    use_sim_time: False
    smoother_plugins: ["simple_smoother"]
    simple_smoother:
      plugin: "nav2_smoother::SimpleSmoother"
      tolerance: 1.0e-10
      max_its: 1000
      do_refinement: True

behavior_server:
  ros__parameters:
    costmap_topic: local_costmap/costmap_raw
    footprint_topic: local_costmap/published_footprint
    cycle_frequency: 10.0
    behavior_plugins: ["spin", "backup", "drive_on_heading", "assisted_teleop", "wait" , "escape"]
    spin:
      plugin: "nav2_behaviors/Spin"
    backup:
      plugin: "nav2_behaviors/BackUp"
    escape:
      plugin: "nav2_behaviors/Escape"
    drive_on_heading:
      plugin: "nav2_behaviors/DriveOnHeading"
    wait:
      plugin: "nav2_behaviors/Wait"
    assisted_teleop:
      plugin: "nav2_behaviors/AssistedTeleop"
    global_frame: odom
    robot_base_frame: base_link_fake
    #robot_base_frame: base_link
    transform_tolerance: 0.2
    use_sim_time: False
    simulate_ahead_time: 2.0
    max_rotational_vel: 1.0
    min_rotational_vel: 0.4
    rotational_acc_lim: 3.2
    collision_check: false


robot_state_publisher:
  ros__parameters:
    use_sim_time: False

waypoint_follower:
  ros__parameters:
    use_sim_time: False
    loop_rate: 5
    stop_on_failure: false
    waypoint_task_executor_plugin: "wait_at_waypoint"
    wait_at_waypoint:
      plugin: "nav2_waypoint_follower::WaitAtWaypoint"
      enabled: True
      waypoint_pause_duration: 200

velocity_smoother:
  ros__parameters:
    use_sim_time: False
    smoothing_frequency: 20.0 #5.0
    scale_velocities: False
    feedback: "CLOSED_LOOP"
    max_velocity: [15.0, 15.0, 2.5]
    min_velocity: [-15.0, -15.0, -2.5]
    max_accel: [100.0, 100.0, 100.0]
    max_decel: [-100.0, -100.0, -100.0]
    odom_topic: "/odometry_path"
    odom_duration: 0.1
    deadband_velocity: [0.0, 0.0, 0.0]
    velocity_timeout: 1.0
    # feedback: "OPEN_LOOP"
    # max_velocity: [2.0, 0.0, 1.0]
    # min_velocity: [-2.0, 0.0, -1.0]
    # max_accel: [2.0, 0.0, 1.0]  
    # max_decel: [-2.0, 0.0, -1.0]
    # odom_topic: "Odometry"
    # odom_duration: 0.1
    # deadband_velocity: [0.0, 0.0, 0.0]
    # velocity_timeout: 1.0